# 명령어의 구조
## Operation code + Operand
- 명령어는 ***연산 코드***와 ***피연산자***로 이루어져 있음
- 연산 코드는 ***연산 코드 필드***에, 피연산자는 ***주소 필드***에 할당됨

### Operation Code
- 연산 코드의 종류
    1. 데이터의 전송
    2. 제어의 흐름을 변경
    3. 산술과 논리의 연산
    4. 입력 / 출력의 제어

### Operand
- 보통 연산에 사용할 데이터 혹은 데이터가 저장된 주소를 의미함
- 직접적으로 연산에 사용할 데이터를 저장할 경우 필드의 저장 용량이 협소하므로 데이터를 저장하고 있는 메모리의 주소나 레지스터의 이름을 가리키는 경우가 많음
- 각 명령어는 다수의 피연산자를 가질 수 있고, 하나도 가지고 있지 않을수도 있음

## 오퍼랜드 주소 지정 방식
- 명령어에서 오퍼랜드의 용량은 명령어의 총 용량 중 연산 코드를 제외한 만큼 뿐임
    - 오퍼랜드 내에 3 주소 명령어를 사용할 경우 각각의 오퍼랜드에 사용될 수 있는 공간은 더 작아짐
- 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소라고 함
> 주소 지정 방식 = 유효 주소를 찾는 방법

### 즉시 주소 지정 방식
- 데이터를 직접 오퍼랜드에 입력하는 방식
    - 오퍼랜드의 용량이 부족해서 유효 주소를 모두 표시하지 못할 수 있음

### 직접 주소 지정 방식
- 유효 주소를 직접 입력하는 방식
    - 즉시 주소 지정 방식과 마찬가지로 오퍼랜드의 용량이 부족해서 유효 주소를 모두 표시하지 못할 수 있음

### 간접 주소 지정 방식
- 유효 주소의 주소를 입력하는 방식
    - 유효 주소의 범위는 더 넓어지지만 두 번의 접근을 해야하기 때문에 더 느림

### 레지스터 주소 지정 방식
- 데이터가 저장된 레지스터를 직접 입력하는 방식
    - 주소 지정 방식 보다 더 빠르게 접근 가능, 표현 가능한 레지스터의 크기에 제한이 있을 수 있다는 문제

### 레지스터 간접 주소 지정 방식
- 유효 주소가 저장되어 있는 레지스터를 입력하는 방식
    - 메모리 접근이 한 번으로 줄어 간접 주소 지정 방식보다 빠름